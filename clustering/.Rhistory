?rnorm
help.search("rmorm")
args("rnorm")
install.packages("swirl")
library("swirl")
swirl()
5+7
x <- 5 + 7
x
y <- x -3
y
z <- c(1.1, 9, 3.14)
?c
z
(z, 555, z)
(z,555,z)
(z 555 z)
(z, 555, z)
c(z, 555, z)
z * 2 + 100
my_sqrt <- sqrt(z -1)
my_sqrt
my_div <- (z/my_sqrt)
my_div <- z / my_sqrt
my_div
c(1, 2, 3, 4)
c(1, 2, 3, 4) + c(0, 10)
c(1, 2, 3, 4) + c(0, 10, 100)
(z * 2 + 1000)
(z * 2 + 1000)
info()
(z * 2 + 1000)
main()
z * 2 + 1000
my_div
swirl()
1:20
pi:10
15:1
':'
?`:`
seq(1, 20)
seq(0, 10, by=0.5)
my_seq <- seq(5, 10, length=30)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times = 40)
rep(c(0, 1, 2), times = 10)
rep(c(0, 1, 2), each
| = 10)
rep(c(0, 1, 2), each = 10)
num_vect <- c(0.5, 55, -10, 6)
tf <- num_vect < 1
tf
num_vect >= 6
c("My", "name", "is")
my_char <- c("My", "name", "is")
my_char
paste(my_char, collapse = " ")
my_name <- c(my_char, "Kate")
my_name]
my_name
paste(my_name, collapse = " ")
paste("Hello", "world!", sep = " ")
paste(1:3, c("X", "Y", "Z"), , sep = " ")
paste(1:3, c("X", "Y", "Z"), , sep = " ")
paste(1:3, c("X", "Y", "Z"), , sep = "")
paste(c(1:3), c("X", "Y", "Z"), , sep = " ")
paste(1:3, c("X", "Y", "Z"), sep = "")
paste(LETTERS, 1:4, sep = "-")
x <- c(44, NA, 5, NA)
x*3
y <- rnorm(1000)
y
z <- rep(NA, 1000)
y_data <- sample(c(y, z), 100)
my_data <- sample(c(y, z), 100)
is.na(my_data)
my_na <- is.na(my_data)
my_na
my_data == NA
sum(my_na)
my_data
0/0
Inf/Inf
Inf - Inf
x
x[1:10]
x[is.na(x)]
y <- x[!is.na(x)]
y
y[y > 0]
x[x > 0]
x[!is.na(x) & x > 0]
c(3,5,7)
c(3, 5, 7)
[c(3, 5, 7)]
v <- c(3, 5, 7)
m <- c(3, 5, 7)
a <- c(3, 5, 7)
[f]
[a]
c[3, 5, 7]
c
x[c(3, 5, 7)]
x (i.e. x[0])
i.e. x[0]
x[0]
x[3000]
x[c(-2, -10)]
x[-c(2, 10)]
vect <- c(foo = 11, bar = 2, norf = NA)
vect
names(vect)
vect2 <- c(11, 2, NA)
names(vect2) <- c("foo", "bar", "norf")
identical(vect, vect2)
vect["bar"]
vect[c("foo", "bar")]
my_vector <- c(1:20)
my_vector <- 1:3
my_vector <- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector) <- c(4, 5)
v
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?matrix()
?matrix
View(my_matrix)
View(my_matrix)
View(my_matrix)
View(my_vector)
View(my_vector)
my_matrix2 <- matrix(1:20, (dim(my_vector) <- c(4, 5))
data <- read.csv("segments_1000.csv")
setwd("~/Documents/GIT/R/mapping")
data <- read.csv("segments_1000.csv")
data$age_group <- as.factor(data$age_group)
data$foreign<- as.factor(data$foreign)
newdata <- data.frame(x= numeric(0))
newdata2 <- data.frame(x= numeric(0))
for(i in 1:max(data$route_id))
#install.packages("Cairo")
library(Cairo)
options(shiny.usecairo=T)
options(rgl.useNULL=TRUE)
library("shinyRGL")
library("rgl")
install.packages("Cairo")
library(Cairo)
options(shiny.usecairo=T)
options(rgl.useNULL=TRUE)
library("shinyRGL")
install.packages("Cairo")
install.packages("Cairo")
install.packages("shinyRGL")
install.packages("rgl")
install.packages("rgl")
install.packages("Quandl")
install.packages("knitr")
install.packages("jpeg")
library(Cairo)
options(shiny.usecairo=T)
options(rgl.useNULL=TRUE)
library("shinyRGL")
library("rgl")
#install.packages("Quandl")
library(Quandl)
Quandl.auth("MqhkMx-Z2L-yxTm3XWp7")
library(knitr)
opts_chunk$set(echo=FALSE, fig.align="center",message=FALSE)
library(jpeg)
url <-"http://evenet.me/r/1024px-Matador.JPG"
fn <- paste(tempfile(), "jpeg", sep=".")
download.file(url, fn,
mode = ifelse(Sys.info()['sysname'] == "Windows",
'wb', 'w'))
readImage <- readJPEG(fn)
dm <- dim(readImage)
rgbImage <- data.frame(
x=rep(1:dm[2], each=dm[1]),
y=rep(dm[1]:1, dm[2]),
r.value=as.vector(readImage[,,1]),
g.value=as.vector(readImage[,,2]),
b.value=as.vector(readImage[,,3]))
readBank <- function(){
bankruptcy <- read.csv(file="pred.csv",stringsAsFactors = FALSE, header=TRUE, sep=";", dec= ".")
for (i in 2:7) bankruptcy[,i]  <- as.numeric(as.character(bankruptcy[,i]))
bankruptcy <- bankruptcy[ which(bankruptcy$Автономность < 30 ), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Рентабельность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Оборачиваемость.активов < 10), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
bankruptcy <- bankruptcy[-c(1,195),]
rownames(bankruptcy) <- NULL
return(bankruptcy)
}
bankruptcy <- readBank();
setwd("~/Documents/GIT/R/clustering")
bankruptcy <- readBank();
bankruptcy_backup <- bankruptcy;
ind1 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==1, select=ID: Банкрот)
ind0 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==0, select=ID: Банкрот)
sampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]
sampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]
training_data <- rbind(sampind0, sampind1)
testing_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]
rownames(training_data)<-NULL
rownames(testing_data)<-NULL
rm(ind0, ind1, sampind0, sampind1)
clear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)
training_data_backup <- training_data;
testing_data_backup <- testing_data;
clear_test_backup <- clear_test;
training_data <- NULL
testing_data <- NULL
training_data$values <- training_data_backup
training_data$Банкрот <- training_data$values$Банкрот
testing_data$values <- testing_data_backup
testing_data$Банкрот <- testing_data$values$Банкрот
training_data$values$Банкрот <- NULL
testing_data$values$Банкрот <- NULL
training_data$values$ID <- NULL
testing_data$values$ID <- NULL
for (i in 2:5) training_data$values[,i] <- 1/(1+(exp(-1*training_data$values[,i])))
for (i in 2:5) testing_data$values[,i] <- 1/(1+(exp(-1*testing_data$values[,i])))
bank <- (nrow(training_data$values) -1)*sum(apply(training_data$values, 2,var))
for (i in 2:20) bank[i]  <- sum(kmeans(training_data$values, center = i)$withinss)
x<-1:20
renderPlot({
plot(x, bank, type="b", xlab='Количество кластеров', ylab='Дисперсия случайной величины', col=ifelse(x==5, "red", "black"),
pch=ifelse(x==5, 19, 1))
axis(side=1, at=c(0:20))
})
nr <- NROW(training_data$values)
#ind <- sample(nr, 0.9 * nr, replace = FALSE)
party <- kmeans(training_data$values, 5)
numericInput("km_clusters",
label = h5("Количество кластеров"),
value = 5)
renderPlot({
party <- kmeans(training_data$values, input$km_clusters)
plot(training_data$values, col=party$cluster)
})
renderPlot({
plot(x, bank, type="b", xlab='Количество кластеров', ylab='Дисперсия случайной величины', col=ifelse(x==5, "red", "black"),
pch=ifelse(x==5, 19, 1))
axis(side=1, at=c(0:20))
})
nr <- NROW(training_data$values)
#ind <- sample(nr, 0.9 * nr, replace = FALSE)
party <- kmeans(training_data$values, 5)
#lets see what we got
numericInput("km_clusters",
label = h5("Количество кластеров"),
value = 5)
renderPlot({
party <- kmeans(training_data$values, input$km_clusters)
plot(training_data$values, col=party$cluster)
})
showclustables <- function(){
shinyApp(
ui = fluidPage(
fluidRow(column(3,numericInput("kmnumclusters",
label = h5("Количество кластеров"),
value = 5))),
fluidRow(
dataTableOutput('firsttable')
),fluidRow(
dataTableOutput('secondtable')
)
),
server = function(input, output) {
clusc <- reactive({
clusc <- input$kmnumclusters
})
output$firsttable = renderDataTable({
party<-kmeans(training_data$values,clusc())
kmeans_test <- cl_predict(party, training_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_test, "Банкрот" = training_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
firstTable <- kmeans_test_res
kmeans_predict<- cl_predict(party, testing_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, "Банкрот" = testing_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
firstTable
},options = list(searching = FALSE, paging = FALSE))
output$secondtable = renderDataTable({
party<-kmeans(training_data$values,clusc())
kmeans_test <- cl_predict(party, training_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_test, "Банкрот" = training_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
firstTable <- kmeans_test_res
kmeans_predict<- cl_predict(party, testing_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, "Банкрот" = testing_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
kmeans_test_res
},options = list(searching = FALSE, paging = FALSE))
}
)
}
showclustables()
install.packages("plyr")
install.packages("rmongodb")
install.packages("rmongodb")
install.packages("rmongodb")
