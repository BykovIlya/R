col = voronoiColor,
main="Lloyd's building", asp = 1,
pch = 15, cex=1.5, axes=FALSE,
ylab="", xlab="500 local clusters")
nRegions <- 20
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- voronoiColor <- rgb(voronoiMeans$centers[,3:5])
plot(y ~ x, data=voronoiMeans$centers,
col = voronoiColor,
main="Lloyd's building", asp = 1,
pch = 15, cex=1.5, axes=FALSE,
ylab="", xlab="500 local clusters")
nRegions <- 20 # Number of Voronoi cells.
# Be patient, this takes time.
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- rgb(voronoiMeans$centers[voronoiMeans$cluster, 3:5])
plot(y ~ x, data=rgbImage, col = voronoiColor,
asp = 1, pch = ".", main="Lloyd's building",
axes=FALSE, ylab="", xlab="2000 local clusters")
nRegions <- 20
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- voronoiColor <- rgb(voronoiMeans$centers[,3:5])
plot(y ~ x, data=voronoiMeans$centers,
col = voronoiColor,
main="Lloyd's building", asp = 1,
pch = 15, cex=1.5, axes=FALSE,
ylab="", xlab="500 local clusters")
nRegions <- 2000
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- voronoiColor <- rgb(voronoiMeans$centers[,3:5])
plot(y ~ x, data=voronoiMeans$centers,
col = voronoiColor,
main="Lloyd's building", asp = 1,
pch = 15, cex=1.5, axes=FALSE,
ylab="", xlab="500 local clusters")
nRegions <- 2000 # Number of Voronoi cells.
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- rgb(voronoiMeans$centers[voronoiMeans$cluster, 3:5])
plot(y ~ x, data=rgbImage, col = voronoiColor,
asp = 1, pch = ".", main="Lloyd's building",
axes=FALSE, ylab="", xlab="2000 local clusters")
nRegions <- 2000 # Number of Voronoi cells.
voronoiMeans <- kmeans(rgbImage, centers = nRegions, iter.max = 50)
voronoiColor <- rgb(voronoiMeans$centers[voronoiMeans$cluster, 3:5])
plot(y ~ x, data=rgbImage, col = voronoiColor,
asp = 1, pch = ".", main="Lloyd's building",
axes=FALSE, ylab="", xlab="2000 local clusters")
plot(y ~ x, data=rgbImage, col = voronoiColor,
asp = 1, pch = ".", main="",
axes=FALSE, ylab="", xlab="2000 local clusters")
plot(y ~ x, data=rgbImage, col = voronoiColor,
asp = 1, pch = ".", main="",
axes=FALSE, ylab="", xlab="2000 локальных кластеров")
install.packages("shinyRGL")
library("shinyRGL")
library(devtools)
install_github("shinyRGL", "trestletech")
install.packages("rgl")
library("rgl")
install_github("shinyRGL", "trestletech")
library("shinyRGL")
library("rgl")
webGLOutput("myWebGL")
install.packages("rgl")
library("rgl")
install.packages("igraph")
library("igraph")
# this usually contains cliques of size six
g <- erdos.renyi.game(100, 0.3)
clique.number(g)
cliques(g, min=6)
largest.cliques(g)
# To have a bit less maximal cliques, about 100-200 usually
g <- erdos.renyi.game(100, 0.03)
maximal.cliques(g)
clique.number(g)
cliques(g, min=6)
largest.cliques(g)
g <- erdos.renyi.game(100, 0.3)
clique.number(g)
cliques(g, min=6)
largest.cliques(g)
# To have a bit less maximal cliques, about 100-200 usually
g <- erdos.renyi.game(100, 0.03)
set.seed(123)
# create an example graph
D <- read.table(header=T,text=
'from to
A B
A C
C D
C F
C E
D E
D F
E F')
g1 <- graph.data.frame(D,directed=F)
# plot the original graph
plot(g1)
# for reproducibility of graphs plots (plot.igraph uses random numbers)
set.seed(123)
# create an example graph
D <- read.table(header=T,text=
'from to
A B
A C
C D
C F
C E
D E
D F
E F')
g1 <- graph.data.frame(D,directed=F)
# plot the original graph
plot(g1)
a <- largest.cliques(g1)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g1,vids=clique1)
# plot the clique
plot(g2)
g <- erdos.renyi.game(100, 0.3)
clique.number(g)
cliques(g, min=6)
largest.cliques(g)
plot(g)
g1 <- erdos.renyi.game(100, 0.03)
plot(g1)
maximal.cliques(g1)
plot(maximal.cliques(g1))
g2<-largest.cliques(g)
plot(g2)
a <- largest.cliques(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g1,vids=clique1)
plot(g2)
g <- erdos.renyi.game(100, 0.3)
clique.number(g)
cliques(g, min=6)
a <- largest.cliques(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g1,vids=clique1)
plot(g2)
a[[1]]
a[[1]][1]
clique1 <- a[[1]][1]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g1,vids=clique1)
plot(g2)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
plot(g)
plot(g2)
clique1 <- a[[2]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
clique.number(g)
plot(g)
cliques(g, min=6)
g <- erdos.renyi.game(10, 0.3)
plot(g)
clique.number(g)
cliques(g, min=6)
a <- largest.cliques(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[2]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
plot(g)
plot(g2)
plot(g)
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
g <- erdos.renyi.game(10, 0.3)
clique.number(g)
cliques(g, min=6)
a <- largest.cliques(g)
plot(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
g <- erdos.renyi.game(15, 0.3)
clique.number(g)
cliques(g, min=6)
a <- largest.cliques(g)
plot(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[1]]
# subset the original graph by passing the clique vertices
g2 <- induced.subgraph(graph=g,vids=clique1)
g2 <- graph.full(length(clique1))
V(g2)$name <- V(g)$name[clique1]
g <- erdos.renyi.game(15, 0.3)
clique.number(g)
cliques(g, min=6)
a <- largest.cliques(g)
plot(g)
# let's just take the first of the largest cliques
# (in this case there's just one clique)
clique1 <- a[[1]]
g2 <- graph.full(length(clique1))
V(g2)$name <- V(g)$name[clique1]
clique1 <- a[1]
g2 <- graph.full(length(clique1))
V(g2)$name <- V(g)$name[clique1]
clique1 <- a[[1]]
g2 <- induced.subgraph(graph=g,vids=clique1)
plot(g2)
library("rgl")
## Create a small graph, A->B, A->C, B->C, C->E, D
## A=0, B=1, C=2, D=3, E=4
g <- graph( c(0,1, 0,2, 1,2, 2,4), n=5 )
g <- graph( c(0,1, 0,2, 1,2, 2,4), n=5 )
library("igraph")
g <- graph( c(0,1, 0,2, 1,2, 2,4), n=5 )
rm(g)
g <- graph( c(0,1, 0,2, 1,2, 2,4), n=5 )
g2 <- graph( c(0,1, 0,2, 1,2, 2,4), n=5, dir=FALSE )
g <- graph.formula(Alice-Bob-Cecil-Alice,
Daniel-Cecil-Eugene, Cecil-Gordon )
plot(g)
plot(g1)
## Another undirected graph, ":" notation
g2 <- graph.formula(Alice-Bob:Cecil:Daniel,
Cecil:Daniel-Eugene:Gordon )
## A directed graph
g3 <- graph.formula(Alice +-+ Bob --+ Cecil
+-- Daniel, Eugene --+ Gordon:Helen )
## A graph with isolate vertices
g4 <- graph.formula(Alice -- Bob -- Daniel,
Cecil:Gordon, Helen )
## "Arrows" can be arbitrarily long
g5 <- graph.formula( Alice +---------+ Bob )
plot(g2)
plot(g3)
plot(g4)
plot(g5)
g <- graph.formula(Alice-Bob-Cecil-Alice,
Daniel-Cecil-Eugene, Cecil-Gordon )
## From edge lists
el <- cbind( c(0, 0, 1, 2),
c(1, 2, 2, 4) )
g <- graph.edgelist(el)
g
el <- cbind( c(0, 0, 1, 2),
c(1, 2, 2, 4) )
g <- graph.edgelist(el)
g
## We need some extra code, not in the current version yet
source("http://cneurocvs.rmki.kfki.hu/igraph/plus.R")
## Read the comma-separated value file
vertices <- read.csv("http://cneurocvs.rmki.kfki.hu/igraph/judicial.csv")
## Read the edges, just a table, space separated
edges <- read.table("http://cneurocvs.rmki.kfki.hu/igraph/allcites.txt")
## And create the graph
jg <- graph.data.frame(edges, vertices=vertices, dir=TRUE)
summary(jg)
## Save it for future use
save(jg, file="judicial.Rdata.gz", compress=TRUE)
View(vertices)
View(edges)
plot(jg)
g <- barabasi.game(100, m=1)
g <- simplify(g)
## simple plot
igraph.par("plot.layout", layout.fruchterman.reingold)
plot(g, vertex.size=3, vertex.label=NA, edge.arrow.size=0.6)
## interactive
id <- tkplot(g, vertex.size=3, vertex.label=NA, edge.arrow.size=0.6)
install.packages('tclkt')
library(tcltk)
id <- tkplot(g, vertex.size=3, vertex.label=NA, edge.arrow.size=0.6)
id <- tkplot(g, vertex.size=3, edge.arrow.size=0.6)
id <- tkplot(g)
open3d()
V(g)$degree
library(igraph)
load("termDocMatrix.rdata")
termDocMatrix[5:10,1:20]
# change it to a Boolean matrix
termDocMatrix[termDocMatrix>=1] <- 1
# transform into a term-term adjacency matrix
termMatrix <- termDocMatrix %*% t(termDocMatrix)
# inspect terms numbered 5 to 10
termMatrix[5:10,5:10]
# build a graph from the above matrix
g <- graph.adjacency(termMatrix, weighted=T, mode = "undirected")
# remove loops
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
# set seed to make the layout reproducible
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g, dim = 3)
plot(g, layout=layout1)
V(g)$label.cex <- 2.2 * V(g)$degree / max(V(g)$degree)+ .2
V(g)$label.color <- rgb(0, 0, .2, .8)
V(g)$frame.color <- NA
egam <- (log(E(g)$weight)+.4) / max(log(E(g)$weight)+.4)
E(g)$color <- rgb(.5, .5, 0, egam)
E(g)$width <- egam
# plot the graph in layout1
#plot(g, layout=layout1)
layout1 <- layout.fruchterman.reingold(g, dim = 3)
pos <- rep(0.5,21)
pos[14] = 2
V(g)$degree
hist(V(g)$degree)
edge.disjoint.paths(g, 1, 2)
plot(g)
plotbg()
plot(g,color="black")
plot(g,col="black")
plot(g,cbg="black")
plot(g,bg="black")
par(bg = "black")
plot(g)
par(bg = "grey")
plot(g)
tkplot(g)
plot(g, layout=layout1)
plot(g, layout=layout1)
plot(g, layout=layout1)
pairs(bg="black")
g <- graph.adjacency(termMatrix, weighted=T, mode = "undirected")
# remove loops
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
# set seed to make the layout reproducible
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g, dim = 3)
plot(g, layout=layout1)
par(bg="gray")
plot(g, layout=layout1)
V(g)$label.cex <- 2.2 * V(g)$degree / max(V(g)$degree)+ .2
V(g)$label.color <- rgb(0, 0, .2, .8)
V(g)$frame.color <- NA
egam <- (log(E(g)$weight)+.4) / max(log(E(g)$weight)+.4)
E(g)$color <- rgb(.5, .5, 0, egam)
E(g)$width <- egam
# plot the graph in layout1
#plot(g, layout=layout1)
layout1 <- layout.fruchterman.reingold(g, dim = 3)
pos <- rep(0.5,21)
pos[14] = 2
par(bg="gray")
plot(g, layout=layout1)
ggplot
ggplot()
library(ggplot)
library(ggplots)
library(gplots)
gplot
gplot()
ggplot()
ggplot2()
gplot2()
gplots()
gn <- graph.neighborhood(g, order = 1)
plot(gn[[1]])
gn
plot(gn[[14]])
plot(gn[[21]])
plot(gn[[2]])
termMatrix
eb <- edge.betweenness.community(g)
member <- community.to.membership(g, eb$merges,
step=nrow(eb$merges)-10L+1L)
plot(g,
vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership+1L],
vertex.size=5, layout=layout,  vertex.label=NA,
edge.arrow.size=.2)
member <- community.to.membership(g, eb$merges,
step=nrow(eb$merges)-10L+1L)
plot(g,
vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership],
vertex.size=5, layout=layout,  vertex.label=NA,
edge.arrow.size=.2)
member$membership
member$membership + 1
rainbow(10, .8, .8, alpha=.8)[member$membership]
plot(g,
vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership],
vertex.size=5, layout=layout,  vertex.label=NA,
edge.arrow.size=.2)
plot(g,
vertex.size=5, layout=layout,  vertex.label=NA,
edge.arrow.size=.2)
plot(g,
vertex.color= rainbow(10, .8, .8, alpha=.8)[member$membership],
vertex.size=5, layout=layout1,
edge.arrow.size=.2)
member <- community.to.membership(g, eb$merges,
step=nrow(eb$merges)-5L+1L)
plot(g,
vertex.color= rainbow(5, .8, .8, alpha=.8)[member$membership],
vertex.size=5, layout=layout1,
edge.arrow.size=.2)
eb <- walktrap.community(g)
member <- community.to.membership(g, eb$merges,
step=nrow(eb$merges)-5L+1L)
shinyapps::deployApp
shinyapps::deployApp()
readBank <- function(){
bankruptcy <- read.csv(file="pred.csv",stringsAsFactors = FALSE, header=TRUE, sep=";", dec= ".")
for (i in 2:7) bankruptcy[,i]  <- as.numeric(as.character(bankruptcy[,i]))
bankruptcy <- bankruptcy[ which(bankruptcy$Автономность < 30 ), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Рентабельность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Оборачиваемость.активов < 10), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
bankruptcy <- bankruptcy[-c(1,195),]
rownames(bankruptcy) <- NULL
return(bankruptcy)
}
bankruptcy <- readBank();
View(bankruptcy)
bankruptcy_backup <- bankruptcy;
ind1 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==1, select=ID: Банкрот)
ind0 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==0, select=ID: Банкрот)
sampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]
sampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]
training_data <- rbind(sampind0, sampind1)
testing_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]
rownames(training_data)<-NULL
rownames(testing_data)<-NULL
rm(ind0, ind1, sampind0, sampind1)
clear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)
training_data_backup <- training_data;
testing_data_backup <- testing_data;
clear_test_backup <- clear_test;
training_data <- NULL
testing_data <- NULL
training_data$values <- training_data_backup
training_data$Банкрот <- training_data$values$Банкрот
testing_data$values <- testing_data_backup
testing_data$Банкрот <- testing_data$values$Банкрот
training_data$values$Банкрот <- NULL
testing_data$values$Банкрот <- NULL
training_data$values$ID <- NULL
testing_data$values$ID <- NULL
for (i in 2:5) training_data$values[,i] <- 1/(1+(exp(-1*training_data$values[,i])))
for (i in 2:5) testing_data$values[,i] <- 1/(1+(exp(-1*testing_data$values[,i])))
bank <- (nrow(training_data$values) -1)*sum(apply(training_data$values, 2,var))
for (i in 2:20) bank[i]  <- sum(kmeans(training_data$values, center = i)$withinss)
x<-1:20
```
**Метод K-средних**
Определим оптимальное количества кластеров методом "плечо". Данный метод рассматривает изменение диспресии случайной величины. Следует выбрать такое количество кластеров, при котором, добавление очередного кластера не придаст значительных улучшений в моделировании данных. На графике показано, что с каждым добавлением очередного кластера, изменчивость дисперсии уменьшается. В нашем случае "плечо" соответствует количеству кластеров 5.
plot(x, bank, type="b", xlab='Количество кластеров', ylab='Дисперсия случайной величины', col=ifelse(x==5, "red", "black"),
pch=ifelse(x==5, 19, 1))
axis(side=1, at=c(0:20))
nr <- NROW(training_data$values)
#ind <- sample(nr, 0.9 * nr, replace = FALSE)
party <- kmeans(training_data$values, 5)
plot(training_data$values, col=party$cluster)
kmeans_test <- cl_predict(party, training_data$values)
library(clue)
kmeans_test <- cl_predict(party, training_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_test, "Банкрот" = training_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
kable(kmeans_test_res,digits=2)
kmeans_predict<- cl_predict(party, testing_data$values)
kmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, "Банкрот" = testing_data$Банкрот))
kn<-(NROW(kmeans_test_res)/2)
kmeans_test_rest <- kmeans_test_res[1:kn,]
kmeans_test_rest$Банкрот <-NULL
colnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')
kn1<-kn+1
kn2<-NROW(kmeans_test_res)
kmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]
kmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)
kmeans_test_res<-kmeans_test_rest
kable(kmeans_test_res,digits=2)
shinyapps::deployApp()
plot3d(training_data$values[,c(1,4,5)])
library("rgl")
plot3d(training_data$values[,c(1,4,5)])
party
party$cluster
plot3d(training_data$values[,c(1,4,5)], col=party$cluster)
shinyapps::deployApp()
shinyapps::deployApp()
