{
    "contents" : "---\ntitle: \"Кластерный анализ\"\nauthor: \"Дмитрий Гайдаржи\"\ndate: \"16 апреля 2015 г.\"\noutput: ioslides_presentation\nruntime: shiny\n---\n\n\n```{r ,echo=FALSE,message=F}\n#install.packages(\"Cairo\")\nlibrary(Cairo)\noptions(shiny.usecairo=T)\noptions(rgl.useNULL=TRUE)\nlibrary(\"shinyRGL\")\nlibrary(\"rgl\")\n#install.packages(\"Quandl\")\nlibrary(Quandl)\nQuandl.auth(\"MqhkMx-Z2L-yxTm3XWp7\")\nlibrary(knitr)\nopts_chunk$set(echo=FALSE, fig.align=\"center\",message=FALSE)\nlibrary(jpeg)\nurl <-\"http://evenet.me/r/1024px-Matador.JPG\"\nfn <- paste(tempfile(), \"jpeg\", sep=\".\")\ndownload.file(url, fn, \n              mode = ifelse(Sys.info()['sysname'] == \"Windows\", \n                            'wb', 'w'))\nreadImage <- readJPEG(fn)\ndm <- dim(readImage)\nrgbImage <- data.frame(\n                    x=rep(1:dm[2], each=dm[1]),\n                    y=rep(dm[1]:1, dm[2]),\n                    r.value=as.vector(readImage[,,1]),\n                    g.value=as.vector(readImage[,,2]),\n                    b.value=as.vector(readImage[,,3]))\n\n\n\n```\n\n\n\n\n## Метод K-средних\n```{r, fig.align='center', echo=F}\nreadBank <- function(){\nbankruptcy <- read.csv(file=\"pred.csv\",stringsAsFactors = FALSE, header=TRUE, sep=\";\", dec= \".\")\nfor (i in 2:7) bankruptcy[,i]  <- as.numeric(as.character(bankruptcy[,i]))\nbankruptcy <- bankruptcy[ which(bankruptcy$Автономность < 30 ), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Рентабельность.активов > -6), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Оборачиваемость.активов < 10), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]\nbankruptcy <- bankruptcy[-c(1,195),]\nrownames(bankruptcy) <- NULL\nreturn(bankruptcy)\n}\nbankruptcy <- readBank();\nbankruptcy_backup <- bankruptcy;\nind1 <- subset(bankruptcy, bankruptcy[,\"Банкрот\"]==1, select=ID: Банкрот)\nind0 <- subset(bankruptcy, bankruptcy[,\"Банкрот\"]==0, select=ID: Банкрот)\nsampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]\nsampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]\n\ntraining_data <- rbind(sampind0, sampind1)\ntesting_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]\nrownames(training_data)<-NULL\nrownames(testing_data)<-NULL\nrm(ind0, ind1, sampind0, sampind1)\nclear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)\n\ntraining_data_backup <- training_data;\ntesting_data_backup <- testing_data;\nclear_test_backup <- clear_test;\n\ntraining_data <- NULL\ntesting_data <- NULL\ntraining_data$values <- training_data_backup\ntraining_data$Банкрот <- training_data$values$Банкрот\ntesting_data$values <- testing_data_backup\ntesting_data$Банкрот <- testing_data$values$Банкрот\ntraining_data$values$Банкрот <- NULL\ntesting_data$values$Банкрот <- NULL\ntraining_data$values$ID <- NULL\ntesting_data$values$ID <- NULL\nfor (i in 2:5) training_data$values[,i] <- 1/(1+(exp(-1*training_data$values[,i])))\nfor (i in 2:5) testing_data$values[,i] <- 1/(1+(exp(-1*testing_data$values[,i])))\n\nbank <- (nrow(training_data$values) -1)*sum(apply(training_data$values, 2,var))\nfor (i in 2:20) bank[i]  <- sum(kmeans(training_data$values, center = i)$withinss)\nx<-1:20\n```\n\nСледует выбрать такое количество кластеров, при котором, добавление очередного кластера не придаст значительных улучшений в моделировании данных. \n\n```{r, echo=F}\nrenderPlot({\nplot(x, bank, type=\"b\", xlab='Количество кластеров', ylab='Дисперсия случайной величины', col=ifelse(x==5, \"red\", \"black\"),\n     pch=ifelse(x==5, 19, 1))\naxis(side=1, at=c(0:20))\n})\n\n\nnr <- NROW(training_data$values)\n#ind <- sample(nr, 0.9 * nr, replace = FALSE)\nparty <- kmeans(training_data$values, 5)\n```\n\n## Диаграммы рассеивания\n```{r, echo=F}\n\n#lets see what we got\n\n  numericInput(\"km_clusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5)\n  \n\nrenderPlot({\n  party <- kmeans(training_data$values, input$km_clusters)\n  plot(training_data$values, col=party$cluster)\n})\n```\n\n## 3d\n\n```{r,echo=F,message=F}\n\n kdd <- function() {\n  shinyApp(\n    ui = fluidPage(\n      fluidRow(column(3,numericInput(\"kmnumclusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5))),\n      fluidRow( webGLOutput(\"mykdd\"))     \n    ),\n    server = function(input, output, session) {\n      clusc <- reactive({\n            clusc <- input$kmnumclusters\n          })\n      output$mykdd <- renderWebGL({\n          party<-kmeans(training_data$values,clusc())\n         plot3d(training_data$values[,c(1,4,5)], col=party$cluster)\n      })\n    },\n    options = list(height = 700)\n  )\n}\nkdd()\n```\n\n\n\n\n## Сравнение\n\n\n```{r, echo=F,message=FALSE}\nlibrary(clue)\n\n\nshowclustables <- function(){\nshinyApp(\n  ui = fluidPage(\n    fluidRow(column(3,numericInput(\"kmnumclusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5))),\n    fluidRow(\n    dataTableOutput('firsttable')\n  ),fluidRow(\n    dataTableOutput('secondtable')\n  )\n  ),\n  server = function(input, output) {\n    clusc <- reactive({\n      clusc <- input$kmnumclusters\n    })\n    \n    output$firsttable = renderDataTable({\n      party<-kmeans(training_data$values,clusc())\n      kmeans_test <- cl_predict(party, training_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_test, \"Банкрот\" = training_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\nfirstTable <- kmeans_test_res\nkmeans_predict<- cl_predict(party, testing_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, \"Банкрот\" = testing_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\n      firstTable\n    },options = list(searching = FALSE, paging = FALSE))\n    output$secondtable = renderDataTable({\n      party<-kmeans(training_data$values,clusc())\n      kmeans_test <- cl_predict(party, training_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_test, \"Банкрот\" = training_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\nfirstTable <- kmeans_test_res\nkmeans_predict<- cl_predict(party, testing_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, \"Банкрот\" = testing_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\n      kmeans_test_res\n    },options = list(searching = FALSE, paging = FALSE))\n  }\n)\n}\nshowclustables()\n```\n\n\n\n## K - Means demonstration\n\n```{r, error=FALSE, warning=FALSE}\noptions(shiny.deprecation.messages=FALSE)\nkmeans_cluster <- function(dataset) {\n\n  shinyApp(\n    ui = fluidPage(responsive = FALSE,\n      fluidRow(style = \"padding-bottom: 20px;\",\n        column(4, selectInput('xcol', 'X Variable', names(dataset))),\n        column(4, selectInput('ycol', 'Y Variable', names(dataset),\n                              selected=names(dataset)[[2]])),\n        column(4, numericInput('clusters', 'Cluster count', 3,\n                               min = 1, max = 9))\n      ),\n      fluidRow(\n        plotOutput('kmeans', height = \"400px\")\n      )\n    ),\n\n    server = function(input, output, session) {\n\n      # Combine the selected variables into a new data frame\n      selectedData <- reactive({\n        dataset[, c(input$xcol, input$ycol)]\n      })\n\n      clusters <- reactive({\n        kmeans(selectedData(), input$clusters)\n      })\n\n      output$kmeans <- renderPlot(height = 400, {\n        par(mar = c(5.1, 4.1, 0, 1))\n        plot(selectedData(),\n             col = clusters()$cluster,\n             pch = 20, cex = 3)\n        points(clusters()$centers, pch = 4, cex = 4, lwd = 4)\n      })\n    },\n\n    options = list(height = 500)\n  )\n}\nkmeans_cluster(iris)\n```\n\n\n\n## Кластерный анализ изображения\n\n```{r}\nplot(y ~ x, data=rgbImage, main=\"Матадор\",\n     col = rgb(rgbImage[c(\"r.value\", \"g.value\", \"b.value\")]), \n     asp = 1, pch = \".\")\n```\n\n## Кластерный анализ изображения методом k средних\n\n```{r, echo=FALSE}\ninputPanel(\n  selectInput(\"num_clusters\", label = \"Количество кластеров:\",\n              choices = c(2, 5, 10, 35, 50), selected = 5)\n)\n\nrenderPlot({\n    kColors <- input$num_clusters\n    kMeans <- kmeans(rgbImage[, c(\"r.value\", \"g.value\", \"b.value\")], \n                 centers = kColors)\n    clusterColour <- rgb(kMeans$centers[kMeans$cluster, ])\n\n    plot(y ~ x, data=rgbImage, main=\"\",\n     col = clusterColour, asp = 1, pch = \".\",\n     axes=FALSE, ylab=\"\", \n     xlab=\"\")\n})\n```\n\n## Диаграмма Вороного\nДиаграмма Вороного по плотности мирового населения\n![alt text](http://evenet.me/r/worldpop.gif)\n***Источник: IBM***\n\n\n## Диаграмма Вороного. Матадор\n\n```{r}\n\n\nselectInput(\"num_voron_clusters\", label = \"Количество кластеров:\",\n              choices = c(20, 50, 100, 200, 500, 2000), selected = 20)\n\n\nrenderPlot({\n    voronoiMeans <- kmeans(rgbImage, centers = input$num_voron_clusters, iter.max = 50)\n    voronoiColor <- rgb(voronoiMeans$centers[voronoiMeans$cluster, 3:5])\n    plot(y ~ x, data=rgbImage, col = voronoiColor, \n     asp = 1, pch = \".\", main=\"\",\n     axes=FALSE, ylab=\"\", xlab=paste(input$num_voron_clusters,\"локальных кластеров\", sep=\" \"))\n})\n```\n\n\n\n## Hierarchical heat map\n```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}\nlibrary(gplots)\nrenderPlot({\n    mtscaled <- as.matrix(scale(VADeaths))\n    heatmap(mtscaled,  scale='none', margins=c(15,15), col=greenred(256) )\n     d <- dist(as.matrix(mtcars)) \n    hc <- hclust(d)  \n    plot(hc)\n})\n```\n\n\n\n##  Вес тела и мозга у животных\n```{r,echo=F}\nlibrary(MASS)\nshowanimals <- function(){\nshinyApp(\n  ui = fluidPage(fluidRow(\n    dataTableOutput('mytable')\n  )),\n  server = function(input, output) {\n    output$mytable = renderDataTable({\n      data <- Animals\n      data <- cbind(names = rownames(data), data)\n      data\n    },options = list(searching = FALSE, paging = FALSE))\n  }\n)\n}\nshowanimals()\n```\n\n##  Брахиозавр\n\n![alt text](http://dinosaurs.afly.ru/ii/z/brachiosaurus-1.jpg)\n\n## Hierarchical Practice Animals\n```{r}\n    animals<-Animals\n    animals[,2] <- animals[,2] / 1000\n    animals$rel <- round(animals[,2] / animals[,1] * 100,3)\n    ratio <- animals[,c(3), drop=F]\n    d <- dist(as.matrix( animals[,c(3), drop=F])) \n    hc <- hclust(d, method = \"complete\")  \n    plot(hc, main=\"\", xlab=\"\", ylab=\"\")\n    rect.hclust(hc, k=10, border=\"red\")\n```\n\n\n##  Клика (теория графов)\n\n```{r,echo=F}\n\n#library(devtools)\n\n#install_github(\"shinyRGL\", \"trestletech\")\nlibrary(igraph)\n\nload(\"termDocMatrix.rdata\")\ntermDocMatrix[5:10,1:20]\n # change it to a Boolean matrix\ntermDocMatrix[termDocMatrix>=1] <- 1\n # transform into a term-term adjacency matrix\ntermMatrix <- termDocMatrix %*% t(termDocMatrix)\n # inspect terms numbered 5 to 10\ntermMatrix[5:10,5:10]\n\n\n # build a graph from the above matrix\n g <- graph.adjacency(termMatrix, weighted=T, mode = \"undirected\")\n # remove loops\n g <- simplify(g)\n # set labels and degrees of vertices\n V(g)$label <- V(g)$name\n V(g)$degree <- degree(g)\n # set seed to make the layout reproducible\n set.seed(3952)\n layout1 <- layout.fruchterman.reingold(g, dim = 3)\ng2<-g\nlayout2 <- layout1\n```\n\n## Первый взгляд\n\n```{r, echo=F}\nrenderPlot({\n    par(bg=\"gray\")\n    plot(g2, layout=layout2)\n  }, height = 500, width=700)  \n```\n\n## Второй взгляд\n```{r, echo=F}\n V(g)$label.cex <- 2.2 * V(g)$degree / max(V(g)$degree)+ .2\n V(g)$label.color <- rgb(0, 0, .2, .8)\n V(g)$frame.color <- NA\n egam <- (log(E(g)$weight)+.4) / max(log(E(g)$weight)+.4)\n E(g)$color <- rgb(.5, .5, 0, egam)\n E(g)$width <- egam\n # plot the graph in layout1\n #plot(g, layout=layout1)\n layout1 <- layout.fruchterman.reingold(g, dim = 3)\n pos <- rep(0.5,21)\n pos[14] = 2\nrenderPlot({\n    par(bg=\"gray\")\n    plot(g, layout=layout1)\n  }, height = 500, width=700)  \n\n\n\n```\n\n## 3D\n\n```{r, echo=F}\n\neb <- walktrap.community(g)\nmember <- community.to.membership(g, eb$merges,\n  step=nrow(eb$merges)-5L+1L)\nplotclique <- function() {\n  shinyApp(\n    ui = fluidPage(\n      webGLOutput(\"myClique\")\n    ),\n    server = function(input, output, session) {\n      output$myClique <- renderWebGL({\n        bg3d(rgb(0.2,0.2,0.2))\n        rglplot(g, vertex.size=V(g)$label.cex*10, vertex.color=rainbow(5, .8, .8, alpha=1)[member$membership], vertex.label.color=\"white\", vertex.label.dist=pos,edge.width=E(g)$width, edge.color = E(g)$color,  layout=layout1)\n  })\n    },\n    options = list(height = 700)\n  )\n}\nplotclique()\n```\n",
    "created" : 1428937097426.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2130020582",
    "id" : "73D7514A",
    "lastKnownWriteTime" : 1429179130,
    "path" : "~/R/clustering/presentation.Rmd",
    "project_path" : "presentation.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}