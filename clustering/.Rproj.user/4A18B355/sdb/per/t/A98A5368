{
    "contents" : "---\ntitle: \"Untitled\"\nauthor: \"Dmitrii\"\ndate: \"15 апреля 2015 г.\"\noutput: ioslides_presentation\nruntime: shiny\n---\n\n## Метод K-средних\n```{r, fig.align='center', echo=F}\nreadBank <- function(){\nbankruptcy <- read.csv(file=\"pred.csv\",stringsAsFactors = FALSE, header=TRUE, sep=\";\", dec= \".\")\nfor (i in 2:7) bankruptcy[,i]  <- as.numeric(as.character(bankruptcy[,i]))\nbankruptcy <- bankruptcy[ which(bankruptcy$Автономность < 30 ), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Рентабельность.активов > -6), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Оборачиваемость.активов < 10), ]\nbankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]\nbankruptcy <- bankruptcy[-c(1,195),]\nrownames(bankruptcy) <- NULL\nreturn(bankruptcy)\n}\nbankruptcy <- readBank();\nbankruptcy_backup <- bankruptcy;\nind1 <- subset(bankruptcy, bankruptcy[,\"Банкрот\"]==1, select=ID: Банкрот)\nind0 <- subset(bankruptcy, bankruptcy[,\"Банкрот\"]==0, select=ID: Банкрот)\nsampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]\nsampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]\n\ntraining_data <- rbind(sampind0, sampind1)\ntesting_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]\nrownames(training_data)<-NULL\nrownames(testing_data)<-NULL\nrm(ind0, ind1, sampind0, sampind1)\nclear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)\n\ntraining_data_backup <- training_data;\ntesting_data_backup <- testing_data;\nclear_test_backup <- clear_test;\n\ntraining_data <- NULL\ntesting_data <- NULL\ntraining_data$values <- training_data_backup\ntraining_data$Банкрот <- training_data$values$Банкрот\ntesting_data$values <- testing_data_backup\ntesting_data$Банкрот <- testing_data$values$Банкрот\ntraining_data$values$Банкрот <- NULL\ntesting_data$values$Банкрот <- NULL\ntraining_data$values$ID <- NULL\ntesting_data$values$ID <- NULL\nfor (i in 2:5) training_data$values[,i] <- 1/(1+(exp(-1*training_data$values[,i])))\nfor (i in 2:5) testing_data$values[,i] <- 1/(1+(exp(-1*testing_data$values[,i])))\n\nbank <- (nrow(training_data$values) -1)*sum(apply(training_data$values, 2,var))\nfor (i in 2:20) bank[i]  <- sum(kmeans(training_data$values, center = i)$withinss)\nx<-1:20\n```\n\nСледует выбрать такое количество кластеров, при котором, добавление очередного кластера не придаст значительных улучшений в моделировании данных. \n\n```{r, echo=F}\nrenderPlot({\nplot(x, bank, type=\"b\", xlab='Количество кластеров', ylab='Дисперсия случайной величины', col=ifelse(x==5, \"red\", \"black\"),\n     pch=ifelse(x==5, 19, 1))\naxis(side=1, at=c(0:20))\n})\n\n\nnr <- NROW(training_data$values)\n#ind <- sample(nr, 0.9 * nr, replace = FALSE)\nparty <- kmeans(training_data$values, 5)\n```\n\n## Диаграммы рассеивания\n```{r, echo=F}\n\n#lets see what we got\n\n  numericInput(\"km_clusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5)\n  \n\nrenderPlot({\n  party <- kmeans(training_data$values, input$km_clusters)\n  plot(training_data$values, col=party$cluster)\n})\n```\n\n## Сравнение\n\n\n```{r, echo=F,message=FALSE}\nlibrary(clue)\n\n\nshowclustables <- function(){\nshinyApp(\n  ui = fluidPage(\n    fluidRow(column(3,numericInput(\"kmnumclusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5))),\n    fluidRow(\n    dataTableOutput('firsttable')\n  ),fluidRow(\n    dataTableOutput('secondtable')\n  )\n  ),\n  server = function(input, output) {\n    clusc <- reactive({\n      clusc <- input$kmnumclusters\n    })\n    \n    output$firsttable = renderDataTable({\n      party<-kmeans(training_data$values,clusc())\n      kmeans_test <- cl_predict(party, training_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_test, \"Банкрот\" = training_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\nfirstTable <- kmeans_test_res\nkmeans_predict<- cl_predict(party, testing_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, \"Банкрот\" = testing_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\n      firstTable\n    },options = list(searching = FALSE, paging = FALSE))\n    output$secondtable = renderDataTable({\n      party<-kmeans(training_data$values,clusc())\n      kmeans_test <- cl_predict(party, training_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_test, \"Банкрот\" = training_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\nfirstTable <- kmeans_test_res\nkmeans_predict<- cl_predict(party, testing_data$values)\nkmeans_test_res <- as.data.frame(table(cluster = kmeans_predict, \"Банкрот\" = testing_data$Банкрот))\nkn<-(NROW(kmeans_test_res)/2)\nkmeans_test_rest <- kmeans_test_res[1:kn,]\nkmeans_test_rest$Банкрот <-NULL\ncolnames(kmeans_test_rest)<-c('№ кластера','Не банкрот')\nkn1<-kn+1\nkn2<-NROW(kmeans_test_res)\nkmeans_test_rest$'Банкрот' <- kmeans_test_res[kn1:kn2,3]\nkmeans_test_rest$'Доля банкротов от общего числа (в %)' <- round(kmeans_test_rest$'Банкрот'/(kmeans_test_rest$'Не банкрот' + kmeans_test_rest$'Банкрот')*100,digits=2)\nkmeans_test_res<-kmeans_test_rest\n      kmeans_test_res\n    },options = list(searching = FALSE, paging = FALSE))\n  }\n)\n}\nshowclustables()\n```\n\n## 3d\n\n```{r,echo=F,message=F}\nlibrary(Cairo)\noptions(shiny.usecairo=T)\noptions(rgl.useNULL=TRUE)\nlibrary(\"shinyRGL\")\nlibrary(\"rgl\")\n kdd <- function() {\n  shinyApp(\n    ui = fluidPage(\n      fluidRow(column(3,numericInput(\"kmnumclusters\", \n        label = h5(\"Количество кластеров\"), \n        value = 5))),\n      fluidRow( webGLOutput(\"mykdd\"))     \n    ),\n    server = function(input, output, session) {\n      clusc <- reactive({\n            clusc <- input$kmnumclusters\n          })\n      output$mykdd <- renderWebGL({\n          party<-kmeans(training_data$values,clusc())\n         plot3d(training_data$values[,c(1,4,5)], col=party$cluster)\n      })\n    },\n    options = list(height = 700)\n  )\n}\nkdd()\n```\n",
    "created" : 1429094332873.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2608820615",
    "id" : "A98A5368",
    "lastKnownWriteTime" : 1429178721,
    "path" : "~/R/clustering/test.Rmd",
    "project_path" : "test.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}