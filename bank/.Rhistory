source('C:/Users/Екатерина/Desktop/install_all.R', echo=TRUE)
Sys.setenv(LANG = "en")
install.packages("ISLR")
library("ISLR")
install.packages("tree")
library("tree")
attach(Carseats)
head(Carseats)
Hight <- ifelse(Carseats$Sales >=8, "Yes", "No" )
length(Hight)
Carseats <- data.frame(Carseats, Hight)
Carseats$Sales <- NULL
set.seed(2)
train = sample(1:nrow(Carseats), nrow(Carseats)/3)
test = - train
training_data = Carseats[train,]
testing_data = Carseats[test,]
testing_Hight = Hight[test]
#training
tree_model = tree(Hight ~ ., training_data)
plot(tree_model)
text(tree_model, pretty=0)
tree_pred = predict(tree_model, testing_data, type="class")
mean(tree_pred != testing_Hight)
set.seed(3)
cv_tree - cv.tree(tree_model, FUN = prune.misclass)
cv_tree <- cv.tree(tree_model, FUN = prune.misclass)
plot(cv_tree$size,cv_tree$dev)
plot(cv_tree$size,cv_tree$dev, type = "b")
plot(cv_tree$size,cv_tree$dev, type = "b")
pruned_model <= prune.misclass(tree_model, best = 4) #взяли с графика 4
plot(pruned_model)
pruned_model <- prune.misclass(tree_model, best = 4) #взяли с графика 4
plot(pruned_model)
text(pruned_model, pretty=0)
plot(cv_tree$size,cv_tree$dev, type = "b")
pruned_model <- prune.misclass(tree_model, best = 9) #взяли с графика 9
plot(pruned_model)
text(pruned_model, pretty=0)
tree_pred = predict(pruned_model, testing_data, type="class")
mean(tree_pred != testing_Hight)
attach(Carseats)
library("ISLR")
library("tree")
attach(Carseats)
library("ISLR")
library("tree")
attach(Carseats)
head(Carseats)
Hight <- ifelse(Carseats$Sales >=8, "Yes", "No" )
length(Hight)
Carseats <- data.frame(Carseats, Hight)
Carseats$Sales <- NULL
set.seed(2)
train = sample(1:nrow(Carseats), nrow(Carseats)/3)
test = - train
training_data = Carseats[train,]
testing_data = Carseats[test,]
testing_Hight = Hight[test]
#training
tree_model = tree(Hight ~ ., training_data)
plot(tree_model)
text(tree_model, pretty=0)
tree_pred = predict(tree_model, testing_data, type="class")
mean(tree_pred != testing_Hight)
set.seed(3)
cv_tree <- cv.tree(tree_model, FUN = prune.misclass)
plot(cv_tree$size,cv_tree$dev, type = "b")
pruned_model <- prune.misclass(tree_model, best = 9) #взяли с графика 9
plot(pruned_model)
text(pruned_model, pretty=0)
tree_pred = predict(pruned_model, testing_data, type="class")
mean(tree_pred != testing_Hight)
set.seed(3)
cv_tree <- cv.tree(tree_model, FUN = prune.misclass)
plot(cv_tree$size,cv_tree$dev, type = "b")
pruned_model <- prune.misclass(tree_model, best = 4) #взяли с графика 9
plot(pruned_model)
text(pruned_model, pretty=0)
tree_pred = predict(pruned_model, testing_data, type="class")
mean(tree_pred != testing_Hight)
library("ggplot2")
library("ggplot2")
library("memisc")
library("lmtest")
library("memisc")
library("lmtest")
df <- diamonds
View(df)
summary(diamonds)
head(diamonds)
a <- lm(log(price) ~ log(carat), data =diamonds)
summary(a)
a <- lm(price ~ carat + x, data =diamonds)
summary(a)
a <- lm(price ~ carat, data =diamonds)
summary(a)
a <- step(lm(price ~ carat + depth + cut, data =diamonds))
summary(a)
d <- step(lm(price ~ carat , data =diamonds))
summary(в)
summary(d)
anova(d,a)
resettest(a)
qplot(data=df, log(carat), log(price), color = clarity) + facet_wrap(~cut)
a <- lm(price ~ carat + depth + cut, data =diamonds)
mtable(a)
resettest(a)
c <- lm(price ~ carat + clarity, data =diamonds)
summary(c)
a <- lm(price ~ carat + depth + cut, data =diamonds)
summery(d)
summary(d)
summary(a)
fruit <- c ( "apple", "orange", "peach" )
length(fruit[1])
df1 <- data.frame(amount= c(10,20,30), product=c("ball","glove","shirt"))
str(df1)
df2 <- subset(df1,df1$amount<15)
df2 <- subset(df1$amount<15)
fruit <- c ( "apple", "orange", "peach" )
fruit[-2]
df1 <- data.frame(amount= c(10,20,30), product=c("ball","glove","shirt"))
str(df1)
execute( "plot_maps.R")
run( "plot_maps.R")
source( "plot_maps.R")
measures <- data.frame(height=c(160,170,180), weight=c(65,80,85) )
cor( measures$height, measures$weight)
df2 <- df1[amount<15,]
df1 <- data.frame(amount= c(10,20,30), product=c("ball","glove","shirt"))
df2 <- df1[df1$amount<15,]
df2 <- df1[amount<15,]
df2 <- df1[*,amount<15]
m <- matrix( c(1,2,3,4,5,6,7,8), nrow=2, ncol=4)
print (m[1,3])
View(m)
a <- c (1, 3, 5)
b <- c (2)
c <- a * b
list.files()
setwd("C:/Users/Екатерина/SkyDrive.old/Documents")
setwd("C:/Users/Екатерина/Documents/GitHub/R/bank")
rmarkdown::render("reg_tree_neural.Rmd")
#install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
#install.packages("MASS", dependencies=TRUE)
library("MASS")
#install.packages("epicalc", dependencies=TRUE)
library("epicalc")
#install.packages("outliers", dependencies = TRUE)
library("outliers")
#install.packages("rpart", dependencies = TRUE)
library("rpart")
#install.packages("randomForest", dependencies = TRUE)
library("randomForest")
#install.packages("C50", dependencies = TRUE)
library("C50")
#install.packages("neuralnet", dependencies = TRUE)
library("neuralnet")
#install.packages("knitr", dependencies = TRUE)
library("knitr")
install.packages("pander", dependencies = TRUE)
library("pander")
#считываем данные из файла
bankruptcy <- read.csv(file="Предприятия-А.csv",stringsAsFactors = FALSE, header=TRUE, sep=";", dec= ".")
for (i in 2:7) bankruptcy[,i]  <- as.numeric(as.character(bankruptcy[,i]))
#Посмотрим на наши данные
summary(bankruptcy)
pairs(Банкрот ~ Ликвидность.активов + Рентабельность.активов	+ Доходность.активов	+ Автономность +	Оборачиваемость.активов,data = bankruptcy, main = "Диаграммы рассеивания для всех переменных")
boxplot(Ликвидность.активов ~ Банкрот , data = bankruptcy, xlab = "Ликвидность активов", ylab = "Банкрот", main = "Зависимость банкротства от ликвидности активов")
boxplot(Рентабельность.активов ~ Банкрот , data = bankruptcy, xlab = "Рентабельность активов", ylab = "Банкрот", main = "Зависимость банкротства от рентабельности активов")
boxplot(Доходность.активов ~ Банкрот , data = bankruptcy, xlab = "Доходность активов", ylab = "Банкрот", main = "Зависимость банкротства от доходности активов")
boxplot(Автономность ~ Банкрот , data = bankruptcy, xlab = "Автономность", ylab = "Банкрот", main = "Зависимость банкротства от автономности активов")
boxplot(Оборачиваемость.активов ~ Банкрот , data = bankruptcy, xlab = "Оборачиваемость.активов", ylab = "Банкрот", main = "Зависимость банкротства от оборачиваемости активов")
bankruptcy <- bankruptcy[ which(bankruptcy$Автономность < 30 ), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Рентабельность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Оборачиваемость.активов < 10), ]
bankruptcy <- bankruptcy[ which(bankruptcy$Доходность.активов > -6), ]
#Смотрим итоговую выборку
summary(bankruptcy)
boxplot(Рентабельность.активов ~ Банкрот , data = bankruptcy, xlab = "Рентабельность активов", ylab = "Банкрот", main = "Зависимость банкротства от рентабельности активов")
boxplot(Доходность.активов ~ Банкрот , data = bankruptcy, xlab = "Доходность активов", ylab = "Банкрот", main = "Зависимость банкротства от доходности активов")
boxplot(Автономность ~ Банкрот , data = bankruptcy, xlab = "Автономность", ylab = "Банкрот", main = "Зависимость банкротства от автономности активов")
boxplot(Оборачиваемость.активов ~ Банкрот , data = bankruptcy, xlab = "Оборачиваемость.активов", ylab = "Банкрот", main = "Зависимость банкротства от оборачиваемости активов")
#сбалансированно бьем выборку на тестовую и проверочную
ind1 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==1, select=ID: Банкрот)
ind0 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==0, select=ID: Банкрот)
sampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]
sampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]
training_data <- rbind(sampind0, sampind1)
testing_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]
rownames(training_data)<-NULL
rownames(testing_data)<-NULL
rm(ind0, ind1, sampind0, sampind1, i)
clear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)
#строим логистическую регрессию, оказалось, что Автономность мало влияет на Банкротство
glm.out <- step(glm(Банкрот ~ Ликвидность.активов + Рентабельность.активов + Доходность.активов + Оборачиваемость.активов, family=binomial, data=training_data))
summary(glm.out)
boxplot(Рентабельность.активов ~ Банкрот , data = bankruptcy, xlab = "Рентабельность активов", ylab = "Банкрот", main = "Зависимость банкротства от рентабельности активов")
boxplot(Доходность.активов ~ Банкрот , data = bankruptcy, xlab = "Доходность активов", ylab = "Банкрот", main = "Зависимость банкротства от доходности активов")
boxplot(Автономность ~ Банкрот , data = bankruptcy, xlab = "Автономность", ylab = "Банкрот", main = "Зависимость банкротства от автономности активов")
boxplot(Оборачиваемость.активов ~ Банкрот , data = bankruptcy, xlab = "Оборачиваемость.активов", ylab = "Банкрот", main = "Зависимость банкротства от оборачиваемости активов")
#сбалансированно бьем выборку на тестовую и проверочную
ind1 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==1, select=ID: Банкрот)
ind0 <- subset(bankruptcy, bankruptcy[,"Банкрот"]==0, select=ID: Банкрот)
sampind1 <- ind1[sample(1:nrow(ind1), 53, replace=FALSE),]
sampind0 <- ind0[sample(1:nrow(ind0), 158, replace=FALSE),]
training_data <- rbind(sampind0, sampind1)
testing_data <- bankruptcy[!(bankruptcy$ID %in% training_data$ID),]
rownames(training_data)<-NULL
rownames(testing_data)<-NULL
rm(ind0, ind1, sampind0, sampind1, i)
clear_test <- subset(testing_data, select=Ликвидность.активов:Банкрот)
#строим логистическую регрессию, оказалось, что Автономность мало влияет на Банкротство
glm.out <- step(glm(Банкрот ~ Ликвидность.активов + Рентабельность.активов + Доходность.активов + Оборачиваемость.активов, family=binomial, data=training_data))
summary(glm.out)
confint(glm.out)
exp(glm.out$coefficients)
exp(confint(glm.out))
#Округлим полученные значения
testing_data$predicted_value_log <-  predict(glm.out, newdata = clear_test, type = "response")
convert <- function(data){if(data >= 0.5)return (1) else return (0)}
testing_data$predicted_value_log <- lapply(testing_data$predicted_value_log, convert)
#Строим регрессионное дерево
reg_tree <- rpart(Банкрот ~ Ликвидность.активов + Рентабельность.активов + Доходность.активов + Оборачиваемость.активов, data = training_data, method = "anova")
printcp(reg_tree)
plotcp(reg_tree) # покажем график кросс-валидации
summary(reg_tree)
rsq.rpart(reg_tree) # visualize cross-validation results
plot(reg_tree, uniform=TRUE, main="Дерево регрессии")
text(reg_tree, use.n=TRUE, all=TRUE, cex=.8)
#Тестим дерево
testing_data$predicted_value_regtree <- predict(reg_tree,  clear_test, type = c("vector", "prob", "class", "matrix"), na.action = na.pass)
correct <- function(data){if(data >= 0.5)return (1) else return (0)}
testing_data$predicted_value_regtree <- lapply(testing_data$predicted_value_regtree, correct)
#Метод random forests
fit <- randomForest(Банкрот ~ Ликвидность.активов + Рентабельность.активов + Доходность.активов + Оборачиваемость.активов, data=training_data)
print(fit) # view results
importance(fit) # importance of each predictor
#Тестим дерево
testing_data$predicted_value_random <-predict(fit, clear_test, type="response" )
testing_data$predicted_value_random <- lapply(testing_data$predicted_value_random, correct)
plot(fit)
#Алгоритм C.5.0
reg_tree_c50 <- C5.0(x = clear_test, y = clear_test$Банкрот)
plot(reg_tree_c50)
testing_data$predicted_value_regtreeс50 <- predict(reg_tree_c50,  clear_test)
summary(reg_tree_c50)
#Нейронная сеть
clear_test$Банкрот <- as.integer(clear_test$Банкрот)
training_data$Банкрот <- as.integer(training_data$Банкрот)
clear_test <- as.data.frame(clear_test)
reg_tree_c50 <- C5.0(x = clear_test, y = clear_test$Банкрот)
plot(reg_tree_c50)
testing_data$predicted_value_regtreeс50 <- predict(reg_tree_c50,  clear_test)
summary(reg_tree_c50)
#Нейронная сеть
clear_test$Банкрот <- as.integer(clear_test$Банкрот)
training_data$Банкрот <- as.integer(training_data$Банкрот)
clear_test <- as.data.frame(clear_test)
nn <- neuralnet(Банкрот ~ Ликвидность.активов  + Рентабельность.активов	+ Доходность.активов	+ Автономность +	Оборачиваемость.активов, data = training_data, hidden = 6, stepmax = 2e05, lifesign = "minimal",linear.output=F)
plot(nn, rep = "best")
print(nn)
clear_test <- subset(clear_test, select = c("Ликвидность.активов", "Рентабельность.активов", "Доходность.активов", "Автономность", "Оборачиваемость.активов"))
bankruptcynet.results <- compute(nn,  clear_test)
testing_data$prediction_nn <- round(bankruptcynet.results$net.result)
rmarkdown::render("reg_tree_neural.Rmd")
rmarkdown::render("reg_tree_neural.Rmd")
rmarkdown::render("reg_tree_neural.Rmd")
